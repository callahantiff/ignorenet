# print number of up and down regulated genes between the samples
top_dec_test <- decideTests(efit)
knitr::kable(summary(top_dec_test))
# print diagram of up and down regulated genes
plotMD(efit, column=1, status=top_dec_test[,1], main=colnames(efit)[1], cex = 0.7)
## Process Results
limma::write.fit(efit, top_dec_test, adjust='fdr', file=paste('DE_Results/', id ,'_DEgenes.txt', sep = ' '))
## Visualize results
# volcano plot
ggplot2::theme_update(plot.title = element_text(hjust = 0.5))
ggplot2::ggplot(data = results, aes(x = results$logFC, y = -log10(results$adj.P.Val)), colour = none) +
geom_point(alpha = 0.4, size = 1.75) +
labs(title = paste(id, ': Volcano Plot', sep = ' ')) +
xlim(c(ceiling(-max(results$logFC)), ceiling(max(results$logFC)))) +
ylim(c(0, ceiling(max(-log10(results$adj.P.Val))))) +
ylab(TeX('$-log_{10}$ P-Value')) +
xlab(TeX('$log_{2}$ Fold Change'))
# heatmap - top 100 genes
mvgenes = as.character(rownames(results)[1:100])
c.sample <- EMA::clustering(data = exprs_data_clean[mvgenes, ], metric = 'pearson', method = 'ward')
c.gene <- EMA::clustering(data = t(exprs_data_clean[mvgenes, ]), metric = 'pearson', method = 'ward')
EMA::clustering.plot(tree = c.sample, tree.sup = c.gene, data = exprs_data_clean[mvgenes,
], names.sup = FALSE, lab = groups, trim.heatmap = 0.99, scale = 'row')
## Download Data
id <- 'GSE63310'
url <- paste('https://www.ncbi.nlm.nih.gov/geo/download/?acc=', id, '&format=file', sep = '')
utils::download.file(url, destfile=paste('Raw_GEO_Data/', id, '_RAW.tar', sep=''), mode='wb')
# unzip data to directory, where directory has same name as id
utils::untar(paste('Raw_GEO_Data/', id, '_RAW.tar', sep=''), exdir = paste('Raw_GEO_Data/',
id, sep=''))
# list all files in directory
files <- list.files(path = paste('Raw_GEO_Data/', id, sep=''), full.names=TRUE)
# check to see if data has already been extracteds before extracting
if(!any(grepl('*.txt$', files))){
# unzip sub-directories
sapply(files, function(i) R.utils::gunzip(i, overwrite = TRUE))
} else {
# delete them
lapply(files, function(x) file.remove(x,
pattern = "*.txt$",
full.names = TRUE))
# download data
utils::download.file(url, destfile=paste('Raw_GEO_Data/', id, '_RAW.tar', sep=''), mode='wb')
# unzip data to directory, where directory has same name as id
utils::untar(paste('Raw_GEO_Data/', id, '_RAW.tar', sep=''), exdir = paste('Raw_GEO_Data/', id, sep=''))
# list all files in   directory
files <- list.files(path = paste('Raw_GEO_Data/', id, sep=''), full.names=TRUE)
# then extract new data
sapply(files, function(i) R.utils::gunzip(i, overwrite = TRUE))
}
# delete zipped file
file.remove(paste('Raw_GEO_Data/', id, '_RAW.tar', sep=''))
# download series information on samples
gse <- GEOquery::getGEO('GSE63310', GSEMatrix = TRUE)
# get group info - remove samples we are not including (i.e., 3 and 9)
group_info = as.character(gse[[1]]@phenoData@data$title)[-c(3, 9)]
# get batch info
batch_info = as.character(gse[[1]]@phenoData@data$characteristics_ch1.6)[-c(3, 9)]
# specify GEO accession id
id <- 'GSE63310'
# read in text files and create single matrix of counts
unzipped_files <- list.files(path = paste('Raw_GEO_Data/', id, sep=''), full.names=TRUE)[-c(3, 9)]
# review file
head(read.table(unzipped_files[1]))
# crete DGE object
DGE <- edgeR::readDGE(unzipped_files, columns=c(1,3))
# remove GEO sample IDs from column names
samplenames <- substring(colnames(DGE), nchar(paste('Raw_GEO_Data/', id, sep='')) + 13, nchar(colnames(DGE)))
colnames(DGE) <- samplenames
samplenames
# create groups
group = as.factor(as.character(lapply(samplenames, function(x) sub(',.*', '', group_info[grepl(x, group_info)]))))
group
# DGEList-object contains a samples data frame that stores both cell type (or group) and batch (sequencing lane) informations
DGE$samples$group <- group
lane <- as.factor(as.character(lapply(batch_info, function(x) sub(': ', '', x))))
DGE$samples$lane <- lane
head(DGE$samples)
## Get Gene Annotations ##
# get Entrez gene ids from DGEList-object
geneid <- rownames(DGE)
head(geneid)
# get additional gene information
genes <- AnnotationDbi::select(Mus.musculus, keys=geneid, columns=c('SYMBOL'),
keytype='ENTREZID')
# # aggregate 1:many mappings into single list
# entrez = aggregate(ENTREZID ~ ENSEMBL, data = genes, paste, collapse = ' /// ')
# symbol = aggregate(SYMBOL ~ ENSEMBL, data = genes, paste, collapse = ' /// ')
#
# # merge lists together
# gene_merge = merge(entrez, symbol, by = 'ENSEMBL', all = TRUE)
# add this information to DGEList-object
DGE$genes <- genes
## Log-Transformation
#convert raw count to CPM and log-CPM values
cpm <- edgeR::cpm(DGE)
lcpm <- edgeR::cpm(DGE, log=TRUE)
## Filter Lowly Expressed Genes
# get count of genes with count of 0
table(rowSums(DGE$counts==0)==length(samplenames))
dim(DGE)
# get counts by sample
knitr::kable(data.table(samplenames, counts = as.numeric(lapply(colSums(DGE$counts), function(x) x/1000000))))
# remove genes using cpm > 1 as threshold, where a gene must be expressed in at least 3 samples
keep.exprs <- rowSums(cpm>1) >= 3
DGE <- DGE[keep.exprs,, keep.lib.sizes=FALSE]
dim(DGE)
# visualize density plots before and after filtering
nsamples <- ncol(DGE)
col <- brewer.pal(nsamples, 'Paired')
par(mfrow=c(1,2))
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2,
main='', xlab='')
title(main='A. Raw data', xlab='Log-cpm')
abline(v=0, lty=3)
for (i in 2:nsamples){
den <- density(lcpm[,i])
lines(den$x, den$y, col=col[i], lwd=2)
}
legend('topright', samplenames, text.col=col, bty='n')
lcpm <- cpm(DGE, log=TRUE)
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2,
main='', xlab='')
title(main='B. Filtered data', xlab='Log-cpm')
abline(v=0, lty=3)
for (i in 2:nsamples){
den <- density(lcpm[,i])
lines(den$x, den$y, col=col[i], lwd=2)
}
legend('topright', samplenames, text.col=col, bty='n')
par(mfrow=c(1,1))
#The density of log-CPM values for raw pre-filtered data (A) and post-filtered data (B) are shown for each sample. Dotted vertical lines mark the log-CPM of zero threshold (equivalent to a CPM value of 1) used in the filtering step.
## Normalize Expression Distributions
#trimmed mean of M-values (TMM) (Robinson and Oshlack 2010) is performed using the calcNormFactors function in edgeR
DGE <- calcNormFactors(DGE, method = 'TMM')
# box plots to verify pre-processing
boxplot(cpm(DGE, log = TRUE), col = brewer.pal(9, 'Set1'),
cex.axis = 0.75, cex.lab = 0.5, las=2, cex.main = 1.0,
main = paste(id, ': Distribution of Pre-Processed Expression Data by Sample', sep = ' '),
ylab = 'Log CPM')
## Clustering by Sample and Sequencing Lane
# SAMPLES
par(mfrow=c(1,2))
col.group <- group
levels(col.group) <-  brewer.pal(nlevels(col.group), 'Set1')
col.group <- as.character(col.group)
plotMDS(cpm(DGE, log = TRUE), labels=group, col= col.group)
title(main='Sample groups')
# SEQUENCING LANES
col.lane <- lane
levels(col.lane) <-  brewer.pal(nlevels(col.lane), 'Set2')
col.lane <- as.character(col.lane)
plotMDS(cpm(DGE, log = TRUE), labels=lane, col=col.lane, dim=c(3,4))
title(main='Sequencing lanes')
par(mfrow=c(1,1))
# set-up design matrix
design <- stats::model.matrix(~0+group+lane)
colnames(design) <- gsub('group', '', colnames(design))
design
# set-up contrasts - want ocntrol group to be negative
contr.matrix <- makeContrasts(
BasalvsLP = Basal-LP,
BasalvsML = Basal-ML,
LPvsML = LP-ML,
levels = colnames(design))
contr.matrix
## remove heteroscedascity from count data - voom
par(mfrow=c(1,2))
v <- voom(DGE, design, plot=TRUE)
v
## fit model
fit <- limma::lmFit(v, design)
fit <- limma::contrasts.fit(fit, contrasts=contr.matrix)
efit <- limma::eBayes(fit)
limma::plotSA(efit, main='Final model: Mean−variance trend')
par(mfrow=c(1,1))
# print number of up and down regulated genes between the samples
top_dec_test <- decideTests(efit)
knitr::kable(summary(top_dec_test))
# print number of up and down regulated genes
summary(decideTests(efit))
# re-run model with a cut-off of a log-fold change of 1
tfit <- treat(fit, lfc=1)
top_dec_test <- decideTests(tfit)
summary(top_dec_test)
## Process Results
limma::write.fit(tfit, top_dec_test, adjust='fdr', file=paste('DE_Results/', id ,'_DEgenes.txt', sep = ' '))
# view list of genes significantly expressed across all sample comparisons
de.common <- which(top_dec_test[,1]!=0 & top_dec_test[,2]!=0)
length(de.common)
# visualize in venn diagram
limma::vennDiagram(top_dec_test, circle.col=rainbow(n=3), cex = 0.9)
# MD plot
limma::plotMD(tfit, column=1, status=top_dec_test[,1], main=colnames(tfit)[1],
xlim=c(-8,13), cex.axis = 0.5, cex.lab = 0.5, cex.main=0.75)
limma::plotMD(tfit, column=1, status=top_dec_test[,2], main=colnames(tfit)[2],
xlim=c(-8,13))
limma::plotMD(tfit, column=1, status=top_dec_test[,3], main=colnames(tfit)[3],
xlim=c(-8,13))
# get top DEG by group comparisons
basal.vs.lp <- topTreat(tfit, coef=1, n=Inf)
head(basal.vs.lp)
basal.vs.ml <- topTreat(tfit, coef=2, n=Inf)
head(basal.vs.ml)
# heat map
basal.vs.lp.topgenes <- basal.vs.lp$ENTREZID[1:50]
i <- which(v$genes$ENTREZID %in% basal.vs.lp.topgenes)
cols <- colorRampPalette(brewer.pal(10, 'RdBu'))(256)
gplots::heatmap.2(v$E[i,], scale='row',
labRow=v$genes$SYMBOL[i], labCol=group, col = cols,
trace='none', density.info='density', dendrogram='column', cexRow = 0.5)
## Connect to database
con <- DBI::dbConnect(SQLite(),'GEO_Database/GEOmetadb.sqlite')
# query a table
metadata <- DBI::dbGetQuery(con,'SELECT gse, pubmed_id, title, submission_date, type, overall_design
FROM gse
WHERE gse IN ("GSE14722", "GSE63310")')
# print results
knitr::kable(metadata)
# write metadata to csv
write.csv(metadata,
'GEO_Data/GES_Metadata.csv',
row.names = FALSE,
quote = FALSE)
# close db connection
DBI::dbDisconnect(con)
sessionInfo()
# load needed libraries
library(Biobase)
library(data.table)
library(edgeR)
library(EMA)
library(GEOmetadb)
library(GEOquery)
library(ggplot2)
library(Glimma)
library(gplots)
library(knitr)
library(latex2exp)
library(limma)
library(Mus.musculus)
library(mygene)
library(RColorBrewer)
library(R.utils)
# specify GEO accession id
id = 'GSE14722'
# view dataset information
gse_exp_set <- gse_data[[idx]]
gse_exp_set
# update column names
Biobase::fvarLabels(gse_exp_set) <- make.names(Biobase::fvarLabels(gse_exp_set))
# convert expression set to expression matrix
exprs_data <- Biobase::exprs(gse_exp_set)
# store gene names and samples
GSE_genes = data.frame(rownames(exprs_data),
gse_data[[1]]@featureData@data$ENTREZ_GENE_ID,
gse_data[[1]]@featureData@data$`Gene Symbol`)
names(GSE_genes) = c('probe', 'Genes.ENTREZID', 'Genes.SYMBOL')
samples = colnames(exprs_data)
# set group membership for all samples
groups = as.character(lapply(as.character(gse_exp_set@phenoData@data$source_name_ch1), function(x)
ifelse(length(grep('clampsia', x)) == 1,
'preeclampsia', 'preterm')))
groups
# check metadata to determine if RMA was used during pre-processing
grepl('RMA', gse_exp_set@phenoData@data$data_processing[1])
# create box plots to verify pre-processing
boxplot(exprs_data, col = brewer.pal(9, 'Set1'),
cex.axis = 0.5, cex.lab = 0.65, las=2,
ylab = TeX('$log_{2}$ Intensity'))
# check for NA values
cat('There are', sum(is.na(exprs_data)), 'NA values')
# remove duplicate gene names
exprs_data_clean = exprs_data[!duplicated(rownames(exprs_data)),]
## Filtering
# summarize average gene expression values
avg <- rowMeans(exprs_data_clean)
summary(avg)
# view distribution to determine whether or not filtering is needed
EMA::expFilter(exprs_data_clean, threshold = FALSE, graph = TRUE)
# # filter and discard probesets with a maximum log2 expression value below x, p=0.01
# PUBHI.f = expFilter(PHBI.exprs, threshold=x)
# cluster expression data by sample
sample = EMA::clustering(data = exprs_data_clean, metric = 'pearson', method = 'average')
EMA::clustering.plot(tree = sample, lab = groups, title = 'Filtered Data', scale='row', legend.pos = 'topleft')
## Principle Components Analysis
# segment variation into different components
acp = EMA::runPCA(t(exprs_data_clean), scale = FALSE, lab.sample = groups, plotSample = FALSE, plotInertia = FALSE)
names(acp$eig) = c('eigen', '%var', 'cumm %var')
knitr::kable(head(acp$eig))
# EMA::plotInertia(acp)
# view variation between samples
EMA::plotSample(acp, axes = c(1, 2), lab = groups)
# save cleaned expression data
exp = as.data.frame(cbind(rownames(exprs_data_clean), exprs_data_clean))
names(exp) = c('probe', colnames(exprs_data_clean))
write.table(exp, file = paste('GEO_Data/', id, '_clean_exp_data.txt', sep = ' '),
sep = '\t',
row.names = FALSE,
col.names = TRUE,
quote = FALSE)
## Run Differential Expression Analysis
# create design matrix
design <- stats::model.matrix(~ groups + 0, data.frame(exprs_data_clean))
colnames(design) <- gsub('groups', '', colnames(design))
design
# create constrast
contr.matrix <- limma::makeContrasts(
PEvsPT = preeclampsia-preterm,
levels = colnames(design))
contr.matrix
# fit model
fit <- limma::lmFit(data.frame(exprs_data_clean), design)
fit <- limma::contrasts.fit(fit, contrasts=contr.matrix)
efit <- limma::eBayes(fit)
# get results adjusting for multiple testing using FDR
results = limma::topTable(efit, coef=1, adjust='fdr', lfc=0, number=Inf)
knitr::kable(head(results, n = 10))
# add gene information to efit
efit$genes <- GSE_genes
# print number of up and down regulated genes between the samples
top_dec_test <- decideTests(efit)
knitr::kable(summary(top_dec_test))
# print diagram of up and down regulated genes
plotMD(efit, column=1, status=top_dec_test[,1], main=colnames(efit)[1], cex = 0.7)
## Process Results
limma::write.fit(efit, top_dec_test, adjust='fdr', file=paste('DE_Results/', id ,'_DEgenes.txt', sep = ' '))
## Visualize results
# volcano plot
ggplot2::theme_update(plot.title = element_text(hjust = 0.5))
ggplot2::ggplot(data = results, aes(x = results$logFC, y = -log10(results$adj.P.Val)), colour = none) +
geom_point(alpha = 0.4, size = 1.75) +
labs(title = paste(id, ': Volcano Plot', sep = ' ')) +
xlim(c(ceiling(-max(results$logFC)), ceiling(max(results$logFC)))) +
ylim(c(0, ceiling(max(-log10(results$adj.P.Val))))) +
ylab(TeX('$-log_{10}$ P-Value')) +
xlab(TeX('$log_{2}$ Fold Change'))
# heatmap - top 100 genes
mvgenes = as.character(rownames(results)[1:100])
c.sample <- EMA::clustering(data = exprs_data_clean[mvgenes, ], metric = 'pearson', method = 'ward')
c.gene <- EMA::clustering(data = t(exprs_data_clean[mvgenes, ]), metric = 'pearson', method = 'ward')
EMA::clustering.plot(tree = c.sample, tree.sup = c.gene, data = exprs_data_clean[mvgenes,
], names.sup = FALSE, lab = groups, trim.heatmap = 0.99, scale = 'row')
# specify GEO accession id
id <- 'GSE63310'
# read in text files and create single matrix of counts
unzipped_files <- list.files(path = paste('Raw_GEO_Data/', id, sep=''), full.names=TRUE)[-c(3, 9)]
# review file
head(read.table(unzipped_files[1]))
# crete DGE object
DGE <- edgeR::readDGE(unzipped_files, columns=c(1,3))
# remove GEO sample IDs from column names
samplenames <- substring(colnames(DGE), nchar(paste('Raw_GEO_Data/', id, sep='')) + 13, nchar(colnames(DGE)))
colnames(DGE) <- samplenames
samplenames
# create groups
group = as.factor(as.character(lapply(samplenames, function(x) sub(',.*', '', group_info[grepl(x, group_info)]))))
group
# DGEList-object contains a samples data frame that stores both cell type (or group) and batch (sequencing lane) informations
DGE$samples$group <- group
lane <- as.factor(as.character(lapply(batch_info, function(x) sub(': ', '', x))))
DGE$samples$lane <- lane
head(DGE$samples)
## Get Gene Annotations ##
# get Entrez gene ids from DGEList-object
geneid <- rownames(DGE)
head(geneid)
# get additional gene information
genes <- AnnotationDbi::select(Mus.musculus, keys=geneid, columns=c('SYMBOL'),
keytype='ENTREZID')
# # aggregate 1:many mappings into single list
# entrez = aggregate(ENTREZID ~ ENSEMBL, data = genes, paste, collapse = ' /// ')
# symbol = aggregate(SYMBOL ~ ENSEMBL, data = genes, paste, collapse = ' /// ')
#
# # merge lists together
# gene_merge = merge(entrez, symbol, by = 'ENSEMBL', all = TRUE)
# add this information to DGEList-object
DGE$genes <- genes
## Log-Transformation
#convert raw count to CPM and log-CPM values
cpm <- edgeR::cpm(DGE)
lcpm <- edgeR::cpm(DGE, log=TRUE)
## Filter Lowly Expressed Genes
# get count of genes with count of 0
table(rowSums(DGE$counts==0)==length(samplenames))
dim(DGE)
# get counts by sample
knitr::kable(data.table(samplenames, counts = as.numeric(lapply(colSums(DGE$counts), function(x) x/1000000))))
# remove genes using cpm > 1 as threshold, where a gene must be expressed in at least 3 samples
keep.exprs <- rowSums(cpm>1) >= 3
DGE <- DGE[keep.exprs,, keep.lib.sizes=FALSE]
dim(DGE)
# visualize density plots before and after filtering
nsamples <- ncol(DGE)
col <- brewer.pal(nsamples, 'Paired')
par(mfrow=c(1,2))
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2,
main='', xlab='')
title(main='A. Raw data', xlab='Log-cpm')
abline(v=0, lty=3)
for (i in 2:nsamples){
den <- density(lcpm[,i])
lines(den$x, den$y, col=col[i], lwd=2)
}
legend('topright', samplenames, text.col=col, bty='n')
lcpm <- cpm(DGE, log=TRUE)
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2,
main='', xlab='')
title(main='B. Filtered data', xlab='Log-cpm')
abline(v=0, lty=3)
for (i in 2:nsamples){
den <- density(lcpm[,i])
lines(den$x, den$y, col=col[i], lwd=2)
}
legend('topright', samplenames, text.col=col, bty='n')
par(mfrow=c(1,1))
#The density of log-CPM values for raw pre-filtered data (A) and post-filtered data (B) are shown for each sample. Dotted vertical lines mark the log-CPM of zero threshold (equivalent to a CPM value of 1) used in the filtering step.
## Normalize Expression Distributions
#trimmed mean of M-values (TMM) (Robinson and Oshlack 2010) is performed using the calcNormFactors function in edgeR
DGE <- calcNormFactors(DGE, method = 'TMM')
# box plots to verify pre-processing
boxplot(cpm(DGE, log = TRUE), col = brewer.pal(9, 'Set1'),
cex.axis = 0.75, cex.lab = 0.5, las=2, cex.main = 1.0,
main = paste(id, ': Distribution of Pre-Processed Expression Data by Sample', sep = ' '),
ylab = 'Log CPM')
## Clustering by Sample and Sequencing Lane
# SAMPLES
par(mfrow=c(1,2))
col.group <- group
levels(col.group) <-  brewer.pal(nlevels(col.group), 'Set1')
col.group <- as.character(col.group)
plotMDS(cpm(DGE, log = TRUE), labels=group, col= col.group)
title(main='Sample groups')
# SEQUENCING LANES
col.lane <- lane
levels(col.lane) <-  brewer.pal(nlevels(col.lane), 'Set2')
col.lane <- as.character(col.lane)
plotMDS(cpm(DGE, log = TRUE), labels=lane, col=col.lane, dim=c(3,4))
title(main='Sequencing lanes')
par(mfrow=c(1,1))
# set-up design matrix
design <- stats::model.matrix(~0+group+lane)
colnames(design) <- gsub('group', '', colnames(design))
design
# set-up contrasts - want ocntrol group to be negative
contr.matrix <- makeContrasts(
BasalvsLP = Basal-LP,
BasalvsML = Basal-ML,
LPvsML = LP-ML,
levels = colnames(design))
contr.matrix
## remove heteroscedascity from count data - voom
par(mfrow=c(1,2))
v <- voom(DGE, design, plot=TRUE)
v
## fit model
fit <- limma::lmFit(v, design)
fit <- limma::contrasts.fit(fit, contrasts=contr.matrix)
efit <- limma::eBayes(fit)
limma::plotSA(efit, main='Final model: Mean−variance trend')
par(mfrow=c(1,1))
# print number of up and down regulated genes between the samples
top_dec_test <- decideTests(efit)
knitr::kable(summary(top_dec_test))
# print number of up and down regulated genes
summary(decideTests(efit))
# re-run model with a cut-off of a log-fold change of 1
tfit <- treat(fit, lfc=1)
top_dec_test <- decideTests(tfit)
summary(top_dec_test)
## Process Results
limma::write.fit(tfit, top_dec_test, adjust='fdr', file=paste('DE_Results/', id ,'_DEgenes.txt', sep = ' '))
# view list of genes significantly expressed across all sample comparisons
de.common <- which(top_dec_test[,1]!=0 & top_dec_test[,2]!=0)
length(de.common)
# visualize in venn diagram
limma::vennDiagram(top_dec_test, circle.col=rainbow(n=3), cex = 0.9)
# MD plot
limma::plotMD(tfit, column=1, status=top_dec_test[,1], main=colnames(tfit)[1],
xlim=c(-8,13), cex.axis = 0.5, cex.lab = 0.5, cex.main=0.75)
limma::plotMD(tfit, column=1, status=top_dec_test[,2], main=colnames(tfit)[2],
xlim=c(-8,13))
limma::plotMD(tfit, column=1, status=top_dec_test[,3], main=colnames(tfit)[3],
xlim=c(-8,13))
# get top DEG by group comparisons
basal.vs.lp <- topTreat(tfit, coef=1, n=Inf)
head(basal.vs.lp)
basal.vs.ml <- topTreat(tfit, coef=2, n=Inf)
head(basal.vs.ml)
# heat map
basal.vs.lp.topgenes <- basal.vs.lp$ENTREZID[1:50]
i <- which(v$genes$ENTREZID %in% basal.vs.lp.topgenes)
cols <- colorRampPalette(brewer.pal(10, 'RdBu'))(256)
gplots::heatmap.2(v$E[i,], scale='row',
labRow=v$genes$SYMBOL[i], labCol=group, col = cols,
trace='none', density.info='density', dendrogram='column', cexRow = 0.5)
## Connect to database
con <- DBI::dbConnect(SQLite(),'GEO_Database/GEOmetadb.sqlite')
# query a table
metadata <- DBI::dbGetQuery(con,'SELECT gse, pubmed_id, title, submission_date, type, overall_design
FROM gse
WHERE gse IN ("GSE14722", "GSE63310")')
# print results
knitr::kable(metadata)
# write metadata to csv
write.csv(metadata,
'GEO_Data/GES_Metadata.csv',
row.names = FALSE,
quote = FALSE)
# close db connection
DBI::dbDisconnect(con)
sessionInfo()
